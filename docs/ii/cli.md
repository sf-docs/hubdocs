
Переходя в практическую плоскость, отметим, что on-boarding в AppSec.Hub реализован с помощью скриптов, запускаемых с набором определенных параметров в CLI (Command Line Interface). По существу, такой подход реализует упрощенный способ взаимодействия с REST API системы.

Для сканирования кодовых баз и артефактов используются соответственно два скрипта: ***scan_codebase.py*** и ***scan_artifact.py***, см. таблицу ниже. Скрипты написаны на Python 3.7 и взаимодействуют с бэкендом AppSec.Hub с использованием протокола HTTP. Описание параметров скриптов и примеры их использования для сканирования кодовых баз и различных типов артефактов приведены в [Приложениях 1](../aag/appendix%201/#1-on-boarding) и [2](../aag/appendix%202/#2) соответственно.

Скрипт|Описание
-|-
scan_codebase.py|Сканирование кодовых баз
scan_artifact.py|Сканирование артефактов

В качестве примера поэтапно рассмотрим типовой процесс сканирования кодовой базы.

    py scan_codebase.py --url http://hub.dev.swordfishsecurity.com/ \
        --token ***** \
        --appcode 0902202-1 \
        --codebase http://gitlab.service.yourcompany.com/test/java-web-project.git;master;;/        

1. AppSec.Hub находит приложение, код которого передан с помощью параметра `––appcode`, в противном случае создает новое. Более подробная информация о параметрах приведена в «[Приложение 1. Описание параметров запуска скриптов on-boarding](../aag/appendix%201.md)».
2. AppSec.Hub находит кодовую базу, определенную параметром `--codebase`, в противном случае создает новую.
3. AppSec.Hub находит Security Pipeline для анализа кодовой базы. Если Security Pipeline обнаружен, AppSec.Hub запускает его, в противном случае на основе подходящего шаблона (см. раздел «[Security Pipelines](../aag/security%20pipelines/#security-pipelines)») создается новый Security Pipeline и запускается сканирование. Если подходящий шаблон не найден, генерируется сообщение об ошибке, см. раздел «[Приложение 3. Результаты сканирования](../aag/appendix%203/#3)». В таком случае следует создать соответствующий шаблон Security Pipeline, в пользовательском интерфейсе AppSec.Hub, см. раздел «[Security Pipelines](../aag/security%20pipelines/#security-pipelines)».
4. После завершения сканирования осуществляется возврат результатов с учетом Quality Gate (см. раздел «[Security Pipelines](../aag/security%20pipelines/#security-pipelines)») и в CLI отображается ссылка на результаты сканирования. После перехода по ссылке (требуется предварительная авторизация в AppSec.Hub), можно просмотреть перечень обнаруженных в ходе сканирования Security Issues. Эта функциональность позволяет быстро ознакомиться с проблемами безопасности, выявленными в ходе соответствующего сканирования. Кроме этого, результаты сканирования могут быть сохранены в текстовый файл, который содержит информацию о статусе сканирования и причине его присвоения, использовавшихся при этом практиках и т. д.

Кроме этого, реализован механизм взаимодействия, позволяющий через REST API выполнить импорт результатов сканирования из различных AST инструментов (Checkmarx, Nexus IQ). Такой подход особенной удобен, когда в компании уже выстроен процесс разработки с использованием тех или иных инструментов и стоит задача передачи всех этих данных в AppSec.Hub. При этом нет необходимости запускать сканирование, как в приведенном выше примере. В результате на стороне AppSec.Hub создаются все необходимые объекты и связи: приложения, кодовые базы, Security Pipelines, а также запускается импорт уязвимостей и проверяется соответствие QG.

Для импорта результатов используется скрипт ***import_results.py***. Описание параметров запуска скрипта приведено в разделе «[Приложение 1. Описание параметров запуска скриптов on-boarding](../appendix%201/#1-on-boarding)».